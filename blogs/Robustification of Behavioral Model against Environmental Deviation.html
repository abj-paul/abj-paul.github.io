<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Abhijit Paul" />
  <title>Robustification of Behavioral Design against Environmental Deviation</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="blogs.css">

  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body class="markdown-container">
<header id="title-block-header">
<h1 class="title">Robustification of Behavioral Design against Environmental Deviation</h1>
<p class="author">Abhijit Paul</p>
<p class="date">&lt;2024-06-25 মঙ্গল&gt;</p>
</header>
<p>We consider the three examples available with the paper. And we will evaluate whether it is feasible to express real systems <code>formally</code> using UML diagram.</p>
<h1 id="voting-system">Voting System</h1>
<h2 id="system-design"><span class="done DONE">DONE</span> System Design</h2>
<p>Following is the <code>sys.lts</code> for voting system from a high level of abstraction.</p>
<pre class="LTS"><code>EM = (password -&gt; P1),
P1 = (select -&gt; P2),
P2 = (vote -&gt; P3 | back -&gt; P1),
P3 = (confirm -&gt; EM | back -&gt; P2).
</code></pre>
<p>The following is the UML diagram for it. <img src="../data/voter-sys.png" /></p>
<h2 id="environment"><span class="done DONE">DONE</span> Environment</h2>
<p>Following is the environment definition, albeit simplified from high level of abstraction.</p>
<pre class="LTS"><code>ENV = (v.enter -&gt; VOTER | eo.enter -&gt; EO),
VOTER = (password -&gt; VOTER1),
VOTER1 = (select -&gt; VOTER2),
VOTER2 = (vote -&gt; VOTER3 | back -&gt; VOTER1),
VOTER3 = (confirm -&gt; v.exit -&gt; ENV | omit_confirm -&gt; v.exit -&gt; ENV | back -&gt; VOTER2),
EO = (select -&gt; EO | vote -&gt; EO | confirm -&gt; EO | back -&gt; EO | eo.exit -&gt; ENV).
</code></pre>
<p>And its UML diagram is: <img src="../data/voter-env.png" /></p>
<p>While complex to look at, one can argue that the process flow itself is simple. So it can also be expressed via UML</p>
<h2 id="requirement">Requirement</h2>
<p>The FSP notation for requirement of voting is very simple. The one who enters the password and the one who gives the vote should be the same person.</p>
<pre class="LTS"><code>const NoBody = 0
const Voter = 1
const EO = 2
range WHO = NoBody..EO

P = VOTE[NoBody][NoBody][NoBody],
VOTE[in:WHO][sel:WHO][v:WHO] = (
      v.enter -&gt; VOTE[Voter][sel][v] | eo.enter -&gt; VOTE[EO][sel][v]
    | password -&gt; VOTE[in][sel][in]
    | select -&gt; VOTE[in][in][v]
    | when (sel == v) confirm -&gt; VOTE[in][NoBody][NoBody]
).
</code></pre>
<p>But its corresponding UML is simply not human. <img src="../data/voter-p.png" /></p>
<h1 id="therac25-system">Therac25 System</h1>
<h2 id="system-design-1"><span class="done DONE">DONE</span> System Design</h2>
<p>It comprises of three parallel parts, each can be described separately and simply.</p>
<pre class="LTS"><code>const IntNotSet = 0
const IntXray = 1
const IntEBeam = 2
range IntModeState = IntNotSet .. IntEBeam

INTERFACE = INTERFACE[IntNotSet],
INTERFACE[mode:IntModeState] = (x -&gt; CONFIRM[IntXray] | e -&gt; CONFIRM[IntEBeam]),
CONFIRM[mode:IntModeState] = (up -&gt; INTERFACE | enter -&gt; FIRE[mode]),
FIRE[mode:IntModeState] = (
    when (mode == IntXray) b -&gt; fire_xray -&gt; enter -&gt; INTERFACE
    |
    when (mode == IntEBeam) b -&gt; fire_ebeam -&gt; enter -&gt; INTERFACE
    |
    up -&gt; CONFIRM[mode]
).

BEAM = (x -&gt; XRAY | e -&gt; EBeam),
XRAY = (x -&gt; XRAY | e -&gt; ToEBeam),
ToEBeam = (setMode -&gt; EBeam | x -&gt; XRAY | e -&gt; ToEBeam),
EBeam = (e -&gt; EBeam | x -&gt; ToXray),
ToXray = (setMode -&gt; XRAY | e -&gt; EBeam | x -&gt; ToXray).

SPREADER = (e -&gt; OUTPLACE | x -&gt; SPREADER),
OUTPLACE = (e -&gt; OUTPLACE | x -&gt; SPREADER).

||SYS = (INTERFACE || BEAM || SPREADER).
</code></pre>
<p>The parallel parts can be separately described using UML. <img src="../data/therac-sys-interface.png" /> <img src="../data/therac-sys-beam.png" /> <img src="../data/therac-spreader-beam.png" /> It is easily doable in UML, as we can see above.</p>
<h2 id="environment-1"><span class="done DONE">DONE</span> Environment</h2>
<p>The environment defines user interaction. The user will select XRay or EBeam, continue or go back and finally press Enter.</p>
<pre class="LTS"><code>ENV = (x -&gt; ENV_1 | e -&gt; ENV_1),
ENV_1 = (enter -&gt; ENV_2 | up -&gt; ENV),
ENV_2 = (b -&gt; enter -&gt; ENV | up -&gt; ENV_1).
</code></pre>
<p>The corresponding UML is also very simple. <img src="../data/therac-env.png" /></p>
<h2 id="property">Property</h2>
<p>The safety property defines different state of the spreader and the corresponding interface instruction and says that conflict should not occur.</p>
<pre class="LTS"><code>const InPlace = 0
const OutPlace = 1
range SpreaderState = InPlace .. OutPlace

const NotSet = 2
const Xray = 3
const EBeam = 4
const ToXray = 5
const ToEBeam = 6
range BeamState = NotSet .. ToEBeam

P = P[InPlace][NotSet],
P[spreader:SpreaderState][power:BeamState] = (
    when (power == NotSet || power == Xray || power == ToEBeam) x -&gt; P[InPlace][Xray]
    |
    when (power == NotSet || power == EBeam || power == ToXray) e -&gt; P[OutPlace][EBeam]
    |
    when (power == Xray || power == ToEBeam) e -&gt; P[OutPlace][ToEBeam]
    |
    when (power == EBeam || power == ToXray) x -&gt; P[InPlace][ToXray]
    |
    when (power == ToEBeam) setMode -&gt; P[spreader][EBeam]
    |
    when (power == ToXray) setMode -&gt; P[spreader][Xray]
    |
    when (power != NotSet &amp;&amp; (spreader != OutPlace || power == EBeam || power == ToXray)) b -&gt; P[spreader][power]
).
</code></pre>
<p>The UML is small but quite complex to understand. <img src="../data/therac-p.png" /></p>
<h1 id="pump">Pump</h1>
<p>It is a complex and close to realistic system design.</p>
<h2 id="system-design-2">System Design</h2>
<pre class="LTS"><code>//======================
// Constants and Ranges
//======================

//
// States of the pump alarm
//
const AlarmSilenced = 0
const AlarmSounds = 1

range AlarmState = AlarmSilenced .. AlarmSounds

//
// States of the pump settings
//
const ParamsNotSet = 2    // pump parameters not set yet
const ParamsSet    = 3    // pump parameters already set

range ParamsStateT = ParamsNotSet .. ParamsSet

//
// Locked/unlocked states of a line with respect to a pump channel
//
const LineUnlocked = 4  // line not locked into a pump channel 
const LineLocked   = 5  // line locked into a pump channel

range LineLockStateT = LineUnlocked .. LineLocked

//
// Locked/unlocked states of the pump unit
//
const UnitUnlocked = 6  // the keypad of the pump is not locked
const UnitLocked   = 7  // the keypad of the pump is locked

range UnitLockStateT = UnitUnlocked .. UnitLocked

//
//Plugged/unplugged states of the pump unit
//

const Unplugged = 8 //the pump is not plugged in
const Plugged = 9 //the pump is plugged in 

range PluggedState = Unplugged .. Plugged 

//
//Battery states of the pump unit
//

const BatteryCharge = 12 //the battery has charge
const BatteryLow = 11
const BatteryEmpty = 10 //battery has no charge

range BatteryState = BatteryEmpty .. BatteryCharge

//
//System State
//

const SystemOff = 13
const SystemOn = 14

range SystemState = SystemOff .. SystemOn

//=====================
// Alarm Definitions
//=====================

ALARM = ALARM[AlarmSilenced],
ALARM[alarm_state:AlarmState] =
(
  when (alarm_state == AlarmSounds)
    alarm_rings -&gt; ALARM[alarm_state]
  |
  when (alarm_state == AlarmSounds)
    alarm_silence -&gt; ALARM[AlarmSilenced]
  |
  enable_alarm -&gt; ALARM[AlarmSounds]
  |
  power_failure -&gt; ALARM
).

//=====================
// Process Definitions
//=====================

//Initial Pump State
PUMP_POWER = POWERED[Unplugged][BatteryEmpty],

//Pump has power but not on -- keep track of whether there is any battery and plug state
POWERED[plug_state:PluggedState][battery_state:BatteryState]  = 
(
  when (plug_state == Unplugged) 
    plug_in -&gt; POWERED[Plugged][battery_state]
  |
  when (plug_state == Plugged)
    unplug -&gt; POWERED[Unplugged][battery_state]
  |
  when (battery_state != BatteryEmpty)
    turn_on -&gt; POWER_ON[plug_state][battery_state]
  |
  when (plug_state == Plugged &amp;&amp; battery_state != BatteryCharge)
    battery_charge -&gt; POWERED[plug_state][battery_state+1]
),

//Pump is on
POWER_ON[plug_state:PluggedState][battery_state:BatteryState] = 
(
  when (plug_state == Plugged)
    unplug -&gt; POWER_ON[Unplugged][battery_state]
  |
  when (plug_state == Unplugged)
    plug_in -&gt; POWER_ON[Plugged][battery_state]
  |
  turn_off -&gt; POWERED[plug_state][battery_state]
  |
  when (plug_state == Unplugged &amp;&amp; battery_state == BatteryCharge)
    battery_spent -&gt; POWER_ON[plug_state][BatteryLow]
  |
  when (plug_state == Unplugged &amp;&amp; battery_state == BatteryLow)
    power_failure -&gt; POWERED[Unplugged][BatteryEmpty]
  |
  when (plug_state == Plugged &amp;&amp; battery_state != BatteryCharge)
    battery_charge -&gt; POWER_ON[plug_state][battery_state+1]
  |
  when (plug_state == Unplugged &amp;&amp; battery_state == BatteryLow)
    enable_alarm -&gt; POWER_ON[plug_state][battery_state]
).

//
// Dispense complete
//

const Dispensing = 15
const DispenseDone = 16

range DispenseState = Dispensing .. DispenseDone

//=====================
// Process Definitions
//=====================
range NUM_LINE = 1..1

LINE = LINE[LineUnlocked],

LINE[lineLock:LineLockStateT] = (turn_on -&gt; LINESETUP[ParamsNotSet][lineLock]), 

//
//-Setupmode for the line

LINESETUP[params:ParamsStateT][lineLock:LineLockStateT] = 
( 
  turn_off -&gt; LINE[lineLock]
  |
  power_failure -&gt; LINE[lineLock]
  |
  when (params == ParamsNotSet &amp;&amp; lineLock == LineUnlocked)
    set_rate -&gt; LINESETUP[ParamsSet][lineLock]
  |
  when (params == ParamsSet &amp;&amp; lineLock == LineUnlocked)
    clear_rate -&gt; LINESETUP[ParamsNotSet][lineLock]
  |
  when (params == ParamsSet &amp;&amp; lineLock == LineUnlocked)
    lock_line -&gt; LINESETUP[params][LineLocked]
  |
  when (lineLock == LineLocked)
    erase_and_unlock_line -&gt; LINESETUP[params][LineUnlocked]
  |
  when (params == ParamsSet &amp;&amp; lineLock == LineLocked)
    confirm_settings -&gt; LINEINFUSION[UnitUnlocked]
),

//
// Pump in infusion mode:
// - Always be able to turn the unit off, even if locked
// - Allow the user to lock/unlock the unit
// - Errors could occur with the pump (e.g., line became pinched or plugged)
//
LINEINFUSION[unitLock:UnitLockStateT] =
(
  turn_off -&gt; LINE[LineLocked]
  |
  power_failure -&gt; LINE[LineLocked]
  |
  when (unitLock == UnitUnlocked)
    change_settings -&gt; LINESETUP[ParamsSet][LineLocked]
  |
  when (unitLock == UnitUnlocked)
    lock_unit -&gt; LINEINFUSION[UnitLocked]
  |
  when (unitLock == UnitLocked)
    unlock_unit -&gt; LINEINFUSION[UnitUnlocked]
  |
  when (unitLock == UnitLocked)
    start_dispense -&gt; DISPENSE[SystemOn][Dispensing]
),

DISPENSE[system_state:SystemState][dispense:DispenseState] =
(
  dispense_main_med_flow -&gt; DISPENSE[system_state][DispenseDone]
  |
  when (system_state == SystemOn &amp;&amp; dispense == DispenseDone)
    flow_complete -&gt; unlock_unit -&gt; LINESETUP[ParamsNotSet][LineLocked]
  |
  power_failure -&gt; DISPENSE[SystemOff][Dispensing]
  |
  when (system_state == SystemOff)
    turn_on -&gt; LINESETUP[ParamsNotSet][LineLocked]
  |
  when (system_state == SystemOn)
    turn_off -&gt; LINE[LineLocked]
).

||LINES = (line[NUM_LINE]:LINE)/{
  turn_on/line[NUM_LINE].turn_on,
  turn_off/line[NUM_LINE].turn_off,
  power_failure/line[NUM_LINE].power_failure}.

||SYS = (PUMP_POWER || ALARM || LINES).
</code></pre>
<p>And its UML is equally large. <img src="../data/pump-sys.png" /></p>
<h2 id="environment-2">Environment</h2>
<p>It only considers user interaction so it is simpler.</p>
<pre class="LTS"><code>range LINES = 1..1

//
// Set of actions that the user of the LTSA tool can control in an
// animation of this model.
//
menu UserControlMenu = {
  alarm_silence,

  line[LINES].change_settings,
  line[LINES].clear_rate,
  line[LINES].confirm_settings,
  line[LINES].erase_and_unlock_line,
  line[LINES].lock_line,
  line[LINES].lock_unit,
  line[LINES].set_rate,
  line[LINES].unlock_unit,

  plug_in,
  turn_off,
  turn_on,
  unplug
}

ENV = (plug_in -&gt; turn_on -&gt; CHOOSE),
CHOOSE = (line[i:LINES].set_rate -&gt; RUN[i] | turn_off -&gt; unplug -&gt; ENV),
RUN[i:LINES] = (
    line[i].lock_line -&gt; line[i].confirm_settings -&gt; line[i].lock_unit -&gt; line[i].start_dispense -&gt;
    line[i].unlock_unit -&gt; line[i].erase_and_unlock_line -&gt; CHOOSE
)+{line[LINES].clear_rate, line[LINES].change_settings}.
</code></pre>
<p>The UML diagram is: <img src="../data/pump-env.png" /> Simple.</p>
<h2 id="requirement-1">Requirement</h2>
<p>The property is also simple because it builds upon original system design.</p>
<pre class="LTS"><code>P = (line[1].set_rate -&gt; RATE_SET | power_failure -&gt; P),
RATE_SET = (line[1].set_rate -&gt; RATE_SET | power_failure -&gt; P | line[1].dispense_main_med_flow -&gt; DISPENSE),
DISPENSE = (line[1].dispense_main_med_flow -&gt; DISPENSE | line[1].flow_complete -&gt; P | power_failure -&gt; P).
</code></pre>
<p>The UML is: <img src="../data/pump-p.png" /></p>
<h1 id="comments">Comments</h1>
<p>As we can see,</p>
<ol>
<li><p>Simple systems can be explained but their requirements can't be explained formally via UML.</p></li>
<li><p>For complex systems, UML creates a hard to understand system.</p>
<p>We will now do literature review to provide support for our findings.</p></li>
</ol>
</body>
</html>
